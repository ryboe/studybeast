terraform {
  required_version = "~> 0.12.24"
  required_providers {
    tfe         = "~> 0.15.0"
    google      = "~> 3.15.0"
    google-beta = "~> 3.15.0"
  }
  backend "remote" {}
}

provider "google" {
  project = var.project_name
  region  = var.default_region
  zone    = var.default_zone
}

provider "google-beta" {
  project = var.project_name
  region  = var.default_region
  zone    = var.default_zone
}

resource "google_compute_network" "main_vpc" {
  provider                = google-beta # we need to use the beta provider to enable setting a private IP for the db
  name                    = "main-vpc"
  description             = "The main StudyGoose VPC."
  routing_mode            = "GLOBAL"
  auto_create_subnetworks = true

  lifecycle {
    prevent_destroy = true
  }
}

# We need to allocate an IP block for private IPs. We want everything in the VPC
# to have a private IP. This improves security and latency, since requests to
# private IPs are routed through Google's network, not the Internet. We will
# assign a private IP to the db later when we create it.
resource "google_compute_global_address" "private_ip_block" {
  provider     = google-beta
  name         = "private-ip-block"
  description  = "A block of private IP addresses that are accessible only from within the VPC. The db is assigned on of these."
  purpose      = "VPC_PEERING"
  address_type = "INTERNAL"
  ip_version   = "IPV4"
  # We don't specify a address block because Google will automatically assign one for us.
  prefix_length = 20 # ~4k IPs
  network       = google_compute_network.main_vpc.self_link
}

# This enables private services access. This makes it possible for instances
# within the VPC and Google services to communicate exclusively using internal
# IP addresses. I don't really understand this, but I know it's important. You
# can read the details here:
#   https://cloud.google.com/sql/docs/postgres/configure-private-services-access
resource "google_service_networking_connection" "private_vpc_connection" {
  provider                = google-beta
  network                 = google_compute_network.main_vpc.self_link
  service                 = "servicenetworking.googleapis.com"
  reserved_peering_ranges = [google_compute_global_address.private_ip_block.name]
}

resource "google_compute_firewall" "allow_icmp" {
  name          = "default-allow-icmp"
  description   = "Allow ICMP ingress for all instances. This makes everything ping-able."
  network       = google_compute_network.main_vpc.name
  direction     = "INGRESS"
  priority      = 65534 # second lowest priority. this will be applied widely. setting a low priority makes it easy to be override.
  source_ranges = ["0.0.0.0/0"]

  allow {
    protocol = "icmp"
  }
}

# TODO: is this necessary when we're using private IPs?
resource "google_compute_firewall" "allow_postgres_tcp" {
  name        = "allow-postgres-tcp"
  description = "All TCP ingress on port 5432. This is intended to be applied to the Cloud SQL Postgres db."
  network     = google_compute_network.main_vpc.name
  direction   = "INGRESS"
  priority    = 100
  # TODO: should i enable source and target tags? how do i assign network tags?
  # source_tags = ["api"]
  # target_tags = ["db"]

  allow {
    protocol = "tcp"
    ports    = [5432]
  }
}

resource "google_sql_database" "main" {
  name     = "main"
  instance = google_sql_database_instance.main_primary.name # instance name will be generated by google

  lifecycle {
    prevent_destroy = true
  }
}

resource "google_sql_database_instance" "main_primary" {
  provider         = google-beta
  database_version = "POSTGRES_12"
  # This is a case where terraform can't figure out the dependency relationship
  # between the db instance and private services access. This relationship only
  # exists because we're giving the db a private IP only. If we were giving it
  # a public IP, there would be no dependency on "private services access". So
  # we have to explicitly specify the dependency here. For details, see the note
  # in the docs here:
  #  https://www.terraform.io/docs/providers/google/r/sql_database_instance.html#private-ip-instance
  depends_on = [google_service_networking_connection.private_vpc_connection]

  settings {
    tier              = "db-custom-8-32768" # 8 cores, 32 GB RAM, min size to get max network bandwidth from google
    availability_type = "REGIONAL"          # storage distributed across zones for high availability
    disk_size         = "1700"              # 1.7 TB, min size to get max IOPS from google

    backup_configuration {
      enabled    = true
      start_time = "02:00"
    }

    # number of autovacuum processes. the db is not CPU bound at all. it's IO bound.
    # we can trade some CPU for better IO (from reading fewer dead rows)
    database_flags {
      name  = "autovacuum_max_workers"
      value = "8" # default is 3
    }

    # a checkpoint means shared buffers are flushed to disk. can create a
    # lot of IO load. spread the IO load over 0.7 * 5min = 3.5min. 5min
    # is the checkpoint timeout. we can be more aggressive about lightening
    # the load of a checkpoint because we have an SSD.
    database_flags {
      name  = "checkpoint_completion_target"
      value = "0.7" # default is 0.5
    }

    # prevent four kinds of db read/write errors
    database_flags {
      name  = "default_transaction_isolation"
      value = "serializable"
    }

    # max memory usable by vacuum, create index, or alter table add foreign key.
    # unit is KB
    database_flags {
      name  = "maintenance_work_mem"
      value = "262144" # default is 65536 (64 MB). increase 4X to 256 MB
    }

    # query planner's estimate for cost of a disk access
    database_flags {
      name  = "random_page_cost"
      value = "1.1" # default is 4. should be 1.1 for SSDs
    }

    # per-session memory allocated for creation of temporary tables.
    # not super useful, but cost of raising it without using it is negligible.
    database_flags {
      name  = "temp_buffers"
      value = "8192" # unit is number of 4KB disk blocks. raise to 8192 (32 MB). default is 1024 (4 MB)
    }

    # max amount of memory a query can use. unit is KB.
    database_flags {
      name  = "work_mem"
      value = "16384" # default is 4096 (4 MB). increase 4X to 16 MB
    }

    ip_configuration {
      ipv4_enabled    = false                                     # don't give the db a public IPv4
      private_network = google_compute_network.main_vpc.self_link # give the db a private IP (only accessible within the VPC)
    }

    maintenance_window {
      day  = 6 # saturday
      hour = 9 # 2am PST, 5am EST, 9am UTC
    }
  }
}

resource "google_sql_user" "api_user" {
  name     = "api-user"
  instance = google_sql_database_instance.main_primary.name
  password = var.api_user_db_password
}

variable "api_user_db_password" {
  description = "The db password used by the API servers to connect to the main Postgers db."
  type        = string
}

variable "project_name" {
  description = "The main GCP project name."
  type        = string
  default     = "studygoose-prototype"
}

variable "default_region" {
  description = "The default GCP region (us-central1 is in Iowa) for creating resources."
  type        = string
  default     = "us-central1"
}

variable "default_zone" {
  description = "The default GCP zone for creating zonal resources, like VMs."
  type        = string
  default     = "us-central1-b"
}
